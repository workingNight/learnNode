## 深入浅出node笔记



## node简介
### node的特点
异步I/O 、 事件驱动 、 基于chrome v8引擎、 单线程

### node的应用场景 
I/O密集型  CPU密集型
- 对于长时间的运算： 
1. 编写c/c++扩展的方式更加高效的利用cpu,
2. 通过子进程的方式，将一部分node进程当作常驻服务器进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离

## 模块机制
### commonJs规范
1. 引用  var math = require('math')
2. 定义  exports.add = function() {}
3. 标识  即传递给require()的参数，相对路径、或绝对路径

### Node的模块实现
引入模块，三个步骤： 1.路径分析 2.文件定位 3.编译执行
- 模块类型：核心模块-Node提供的模块 文件模块-用户编写的模块 
    > 谈一下他们。 核心模块是在node源码编译的时候就被编译成二进制文件（一部分核心模块），进程启动时就直接被加载进内存中，将不需要文件定位和编译执行阶段。路径分析阶段也优先执行。
    > 对于文件模块。运行时动态加载

### 包与NPM
commonJS之类的模块规范，一定程度上解决了变量依赖、依赖关系等代码组织性问题，包的出现则是在模块的基础上进异步组织了js代码。package.json 包描述文件，里面的依赖描述表达了这个包引用了别的什么包。

### AMD规范和CMD规范
amd规范，即异步模块定义  define(id, dependencies, factory)
CMD规范，玉伯提出的，    define(factory)


## 异步I/O及实现现状
异步I/O的演化史，由轮询-> 事件通知
现实的异步I/O： 通过让部分线程进行阻塞I/O或者非阻塞I/O轮询技术来完成数据获取，让一个多线程进行计算处理，通过线程间的通信将I/O的到的数据进行传递，这就轻松实现了异步I/O。也称线程池模拟I/O.
libuv --平台兼容性 *nix & windows

### 事件驱动与高性能服务器
事件驱动的实质： 通过主循环加事件触发的方式来运行程序
几种经典的服务器模型： 同步式：一次只能处理一个请求，且其余请求都处于等待状态。 每进程/每请求  每线程/每请求

## 异步编程
### 难点

1. 异常处理： 尝试对异步方法进行try/catch操作只能捕获当次事件循环内的异常，对于callback执行时抛出的异常无能为力。--------> node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，表明没有异常抛出。    
注意点: 不要对用户传递的回调函数进行异常捕获

### 解决方案
事件发布/订阅模式   
Promise模式
流程控制模式。
协程：coroutine co\ generator
对于异步流的一些深入。并发、串行，并发阀值，加锁...

## 内存控制
V8： 虚拟机  -- 那么虚拟机又是什么东西呢
V8限制了内存操作，64位下限制约1.4GB

### 垃圾回收机制
1. 主要的垃圾回收算法： 分代式垃圾回收机制。新生代、老生代
2. Scavenge算法：   新生代中的对象主要是采用这个算法，具体实现中采用了Cheney算法-复制的方式实现，分为2个部分，使用状态的位From空间，闲置状态的为To空间。
    - 当我们分配对象时先是在form空间分配。
    - 当开始垃圾回收的时候会检查form空间里的存活对象，将其复制到to空间，非存活的就释放。
    - 完成复制后from和to空间角色置换。当一个对象经过多次复制之后依然存活时，它将会被认为是生命周期比较长的对象，将会被移动到老生代中，采用新的算法来进行管理。
    - 对象晋升（新生代转进老生代）1. 对象是否经历过Scavenge回收 2. to空间的内存占用比是否超过限制（25%）
3. Mark-Sweep 和 Mark-Compact 标记清除和标记整理
- 标记清除： 遍历堆中的所有对象，并标记活着的对象，在之后的清理阶段中，只清除没有被标记的对象。问题：进行一次标记清除之后，内存空间会出现不连续的状态，这个内存碎片会对后续的内存分配造成问题（放不下大对象）
- 在整理的过程中，将活的对象往一端以移动，移动完成直接清理掉边界外的内存
4. 增量标记 对于老生代中的对象比较多，标记操作造成的停顿就会比较长，把一口的操作拆小。
5. 延迟清理、增量式清理

### 查看垃圾回收日志
在启动时添加  --trace_gc。将会在gc.log文件中得到所有的垃圾回收信息

### 高效使用内存
无法立即回收的内存有闭包和全局变量引用--->会导致老生代中的对象增多   
全局作用域需要知道进程推出才能释放，将导致引用的对象常驻内存。

### 内存指标
process.memoryUsage()可以查看内存使用情况 rss（resident,进程的常驻内存部分）
os模块中的totalmem()\freememo()
堆外内存 buffer

### 内存泄漏
无意间、原因： 缓存、队列消费不及时、作用域未释放
- 慎用内存当缓存，缓存命中可以节省一次I/O的时间。开发者喜欢用对象键值对来缓存东西，但是又没有完善的过期策略。此外可以做一些限制键值对的数量的限制的策略
- 进程内不要使用缓存，这些缓存不可避免的有重复，对物理内存的使用是一种浪费。使用进程外的缓存，redis
- 关注队列状态，消费的速度远小于生产的速度时，就会形成堆积。数据库写入操作的堆积。---->监控队列的长度、异步调用包含超时机制


## 理解Buffer
Buffer主要用于操作字节。Buffer对象类似于数组，元素为16进制的两位数
- <Buffer e6 b7 e5......>
其所再用的内存不是通过V8分配的，属于堆外内存，是在Node的C++层面实现内存的申请
- 字符串编码类型： ASCII UTR-8 Base64 Binary..

### 乱码的产生
不要把Buffer当作字符串来理解。
对于宽字节的中文会出问题。buf.toString()默认以UTF-8为编码，中文字在UTF-8占3个字节
解决办法
1. 调用setEncoding()，可读流在内部会设置一个decoder对象
2. 将多个小Buffer对象拼接为一个Buffer对象，然后再批量转码
- 文件读取配置： hightWaterMark： 64 * 1024 越大越快



##  第七章 网络编程
在web领域，大多数编程语言需要专门的web服务器来作为容器，如ASP需要IIS，JSP需要Tomcat服务器。
node网络模块： net-TCP  dgram-UDP  http https
### TCP
服务器事件。对于net.createServer()创建的服务器而言，它是一个EventEmitter实例
